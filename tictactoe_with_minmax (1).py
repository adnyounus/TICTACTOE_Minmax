# -*- coding: utf-8 -*-
"""TicTacToe_with_minmax.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13SOj3o9fNnUMrmxrn_HT5_7TLelvBC1C
"""

#min-max algo
from copy import copy, deepcopy

global humanTurn,turnCounts
humanTurn = True
turnCounts = 0;

# checks win 
def check_win(win_list):
  for x in range(3):
    if(win_list[x][0] == win_list[x][1] and win_list[x][0] == win_list[x][2] and win_list[x][0] == 2):
      return 2
  for x in range(3):
    if(win_list[0][x] == win_list[1][x] and win_list[0][x] == win_list[2][x] and win_list[0][x] == 2):
      return 2
  if(win_list[0][0] == win_list[1][1] and win_list[0][0] == win_list[2][2] and win_list[0][0] == 2):
      return 2
  if(win_list[0][2] == win_list[1][1] and win_list[0][2] == win_list[2][0] and win_list[0][2] == 2):
      return 2

  for x in range(3):
    if(win_list[x][0] == win_list[x][1] and win_list[x][0] == win_list[x][2] and win_list[x][0] == 1):
      return 1
  for x in range(3):
    if(win_list[0][x] == win_list[1][x] and win_list[0][x] == win_list[2][x] and win_list[0][x] == 1):
      return 1
  if(win_list[0][0] == win_list[1][1] and win_list[0][0] == win_list[2][2] and win_list[0][0] == 1):
      return 1
  if(win_list[0][2] == win_list[1][1] and win_list[0][2] == win_list[2][0] and win_list[0][2] == 1):
      return 1
  
  check_zero = 0
  for i in range(3):
    for j in range(3):
      if(win_list[i][j] == 0):
        check_zero = 1
        break
  if(check_zero == 0):
    return 0
  else:
    return 3


def utility(board, depth):
  var = check_win(board)
  if(var == 1):
    return 1/depth
  elif(var == 2):
    return -1
  elif(var == 0):
    return 0

def max_algo(board, depth):
  var = check_win(board)
  if(var == 1 or var == 2 or var == 0):
    return utility(board, depth)
  util = -100000
  for i in range(3):
    for j in range(3):
      if(board[i][j] == 0):
        xxboard = deepcopy(board)
        xxboard[i][j] = 1
        util = max(util, min_algo(deepcopy(xxboard), depth+1))
  return util      

def min_algo(board, depth):
  var = check_win(board)
  if(var == 1 or var == 2 or var == 0):
    return utility(board, depth)
  util = +100000
  for i in range(3):
    for j in range(3):
      if(board[i][j] == 0):
        xxboard = deepcopy(board)
        xxboard[i][j] = 2
        util = min(util, max_algo(deepcopy(xxboard), depth+1))
  return util  

def choose_PC_move(dummy_board):
  aaa = []
  for i in range(3):
    for j in range(3):
      if(dummy_board[i][j] == 0):
        xxboard = deepcopy(dummy_board)
        xxboard[i][j] = 1
        util = min_algo(deepcopy(xxboard), 1)
        print(f'pc uti {util}')
        aaa.append(PosTrack(i,j,util))
  maxx = -100000
  maxX = 0
  maxY = 0
  for x in aaa:
    #print(f"Value of {x.val}")
    if(maxx < x.val):
      maxx = x.val
      maxX = x.x
      maxY = x.y
  
  #for x in aaa:
    #print(x.__dict__)
  return maxX, maxY  

class PosTrack:
  def __init__(self,x,y,val):
    self.x = x
    self.y = y
    self.val = val

def inputCheck(x,y,board):
  if(x > 2 or y > 2 or x < 0 or y < 0): return False
  if(board[x][y] != 0): return False
  return True


def printBoard(board):
  for i in range(3):
    for j in range(3):
      if(board[i][j] == 2):
        print("X", end =" ")
      elif(board[i][j] == 1):
        print("O", end =" ")
      elif(board[i][j] == 0):
        print(".", end =" ")
    print()


# main
tictactoe_matrix = [[0 for x in range(3)] for y in range(3)]
printBoard(tictactoe_matrix)
while(True):
  axis_x = int(input("enter row:"))           # player select position
  axis_y = int(input("enter colomn:"))        #           ''
  if(not inputCheck(axis_x,axis_y,tictactoe_matrix)):
    continue
  tictactoe_matrix[axis_x][axis_y] = 2;
  turnCounts = turnCounts + 1

  print()
  print("Board after player's turn")
  printBoard(tictactoe_matrix)
  
  var = check_win(deepcopy(tictactoe_matrix))
  if(var == 2):                               # player win check                            # 
    print()                                   #
    print()                                   #
    print("Game Over")                        #
    print("Player wins")                      #
    break

  if(turnCounts == 9):                        # draw
    print()
    print()
    print("Game Over")  
    print("Draw")
    break;


  humanTurn = False
  
  copy = deepcopy(tictactoe_matrix)
  m,n = choose_PC_move(copy) 
  tictactoe_matrix[m][n] = 1;
  turnCounts = turnCounts + 1

  print()
  print("Board after computer's turn")
  printBoard(tictactoe_matrix)
  var = check_win(deepcopy(tictactoe_matrix))

  if(var == 1):                               # comp win check
    if(not humanTurn):                        #
      print()                                 #
      print()                                 #
      print("Game Over")                      #
      print("Computer wins")                  #
      break
  if(turnCounts > 9):                        # draw
    print()
    print()
    print("Game Over")  
    print("Draw")
    break;